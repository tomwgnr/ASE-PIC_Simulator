\documentclass[12pt,a4paper,titlepage,ngerman,pdftex]{report}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{acronym}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{textcomp}
\geometry{a4paper, top=25mm, left=25mm, right=25mm, bottom=25mm,
    headsep=10mm, footskip=12mm}
\usepackage{xcolor}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.827, 0.827, 0.827}
\definecolor{dkblue}{rgb}{0,0,.6}
\definecolor{dkyellow}{cmyk}{0,0,.8,.3}

\lstset{
    language        = php,
    basicstyle      = \small\ttfamily,
    keywordstyle    = \color{dkblue},
    stringstyle     = \color{red},
    identifierstyle = \color{mygreen},
    commentstyle    = \color{gray},
    emph            =[1]{php},
    emphstyle       =[1]\color{black},
    emph            =[2]{if,and,or,else},
    emphstyle       =[2]\color{dkyellow}}

\lstset{ %
    backgroundcolor=\color{backcolour},   % choose the background color
    basicstyle=\footnotesize,        % size of fonts used for the code
    breaklines=true,                 % automatic line breaking only at whitespace
    captionpos=b,                    % sets the caption-position to bottom
    commentstyle=\color{mygreen},    % comment style
    escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
    keywordstyle=\color{blue},       % keyword style
    stringstyle=\color{mymauve},     % string literal stylebreakatwhitespace=false,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=true,
    showtabs=false,
    tabsize=2
}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%    TITLE    %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{titlepage}
        \centering
        %\includegraphics[width=0.15\textwidth]{pic/picsim_logo_full.png}\par\vspace{1cm}
        {\scshape\LARGE Duale Hochschule Baden-Württemberg \par}
        \vspace{1cm}
        {\scshape\Large Advanced Software Engineering 2 \\--\\ Dokumentation\par}
        \vspace{1.5cm}
        {\huge\bfseries PIC-Simulator\par}
        \vspace{2cm}
        {\Large\itshape David Eymann, Tom Wagner\par}
        \vfill
        Dozent\par
        Daniel \textsc{Lindner}

        \vfill

% Bottom of the page
        {\large \today\par}
    \end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%  LISTINGS  %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \pagenumbering{Roman}
    \tableofcontents
    \listoffigures
    \lstlistoflistings

    \onehalfspacing
    \pagenumbering{arabic}

    \chapter{Projektbeschreibung}\label{ch:projektbeschreibung}
    Als Basis für diese Arbeit dient ein PIC-Simulator, PIC steht hierbei für ein Mikrocontroller von Microchip Technology\footnote{\url{https://en.wikipedia.org/wiki/Microchip_Technology}}.
    Der Simulator ist in C-\# geschrieben und mit Windows Forms Erhält er seine Grafische Oberfläche.
    \textbf{Das für diese Abgabe relevante Repository befindet sich unter:} \\ \url{https://github.com/tomwgnr/ASE-PIC_Simulator}\\
    
    

    \section{Einrichtung}\label{sec:einrichtung}

    \chapter{Entwicklung}\label{ch:entwicklung}
    \section{Clean Architecture}\label{sec:cleanarchitecture}
 
    \section{Refactoring}\label{sec:refactoring}

    In diesem Abschnitt wird eine Auswahl der identifizierten Code Smells und eingesetzten Refactorings vorgestellt. Hierbei handelt es sich natürch nicht um alle Beispiele welche in diesem Projekt vorkommen und es sind noch einige, vor allem Code Smells, im Code vorhanden. 

    \subsection{Code Smells}

    \subsubsection{Switch Statement}

    Die urspüngliche 'Decode'- Klasse beinhaltet exakt eine Methode mit dem Namen 'analyse()', welche einen Operationcode einließt und den entsprechenden Command aufruft. In dieser sind eine Reihe von Code Smells zu erkennen: Unter Anderem Code Comments, was hier auf eine Long Method hindeutet.
    Kernproblem dieser Methode ist jedoch das sich darin befindende riesige Switch-Statement und damit der dazugehörige Code Smell. Dies erschwert es unter anderem, einen neuen Command dem PIC-Simulator hinzuzufügen,
    da dieser dem Switch-Statement hinzugefügt werden muss. Dieser Vorgang kann fehleranfällig sein und außerdem wird dadurch das Open-Closed-Principle der SOLID Principles(\autoref{subsec:solid}) verletzt. 
    Dieser Code Smell wurde durch den Einsatz einer Zuständigkeitskette als Entwurfsmuster behoben, welches in \autoref{sec:entwurfsmuster} erläutert wird.

    \subsubsection{Long Method}

    Eine Weitere Methode welche deutlich zu groß ist und definitiv unter den Code Smell Long Method fällt ist die ehemalige 'writeByte()' Methode der 'Memory'- Klasse. Diese ist schnell zu erkennen, da auch hier einige Code Comments zu finden sind und auch einfach an der unnötig hohen Zeilenanzahl.
    Eine zu lange Methode führt zu einer Reihe möglicher Probleme. Dazu gehören erschwerte Lesbarkeit und Wartung sowie erhöhtes Fehlerrisiko und Risiko auf unnötige Wiederholung von Code. Damit werden unter anderem die Programming Principles DRY und Single Responsibility verletzt. 
    Behoben wird der Code Smell durch ein Extract Method refactoring, welches unten beschrieben wird.
    
    \subsubsection{Duplicated Code}

    Die einzelnen Commands beinhalten zu einem größen Teil gleiche oder ähnliche Funktionen, welche in jedem einzelnen Command neu implementiert wurden. Dadurch war ein beträchtlicher Teil des Codes mehrfach vorhanden, was zur Folge hatte,
    dass eine Änderung immer an allen Commands durchgeführt werden musste. Dies wurde in dem Schritt gelöst, in dem auch die 'Cpu'- Klasse aufgelöst wurde und jeder Command in einer eingenen Klasse definiert wurde. 
    Dabei wurde eine abstrakte Oberklasse 'Command' eingeführt, in welcher die sich widerholenden Funktionen definiert sind.

    \subsubsection{Large Class}
    Für den Code Smell Large Klass gibt es zwei auffällige Beispiele. Bevor der Code Refactored wurde basierte der Großteil der Funktionalität auf zwei Klassen, 'Cpu' und 'Simulator', welche beide aus einigen hundert Zeilen Code bestanden und eine große Anzahl an Methoden beinhalteten.
    Dieser Aufbau verstößt gegen einige der Programming Principles, aber primär dem Single Responsibility Principle, weches in \autoref{subsubsec:single_responsibility} erläutert wird. Er stört dabei die Les- und Wartbarkeit des Codes sowie die Möglichkeit zur Erweiterung von Funktionalitäten.
    Aus diesem Grund wurde die 'Cpu'- Klasse komplett aufgelöst und die  Simulator Klasse mit hilfe eines Extract Class Refactorings, welches anschließend erläutert wird, verkleinert.

    \subsection{Refactoring}

    \subsubsection{Extract Method}

    \subsubsection{Extract Class}


    \section{Unit Tests}

    \subsection{Einsatz von Mocks}

    \subsection{ATRIP-Regeln}

    \subsubsection{Automatic}

    \subsubsection{Thorough}\label{subsec:thorough}

    \subsubsection{Repeatable}

    \subsubsection{Independent}

    \subsubsection{Professional}

    \section{Programming Principles}

    \subsection{SOLID}\label{subsec:solid}
    
    \subsubsection{Single responsibility principle}\label{subsubsec:single_responsibility}
    Das Single Responsibility Principle sagt aus, dass eine Klasse nur exakt für eine Funktionalität zuständig ist. Im Umkehrschluss bedeutet dies auch, dass es immer nur einen einzigen Grund geben soll, warum die Klasse geändert werden müsste.
    Ziel dieses Prinzips ist niedrige Kopplung sowie niedrige Komplexität innerhalb der Klasse. In diesem Projekt wurde dieses Prinzip in einigen Klassen angewandt. ein Beispiel dafür sind die Klassen der einzelnen Register. 
    Diese verfügen nur über eine einzige Zuständigkeit: das Auffüllen neuer Datentabellen zur dargestellung der einzelnen Register des Simulators.
    \\
    Screenshot
    \\

    Ein Negativbeispiel ist vor allem die 'Forms'-Klasse, welche viele Funktionen durchführt und damit eine hohe anzahl an Zuständigkeiten und Änderungsdimensionen besitzt. Auch die 'Simulator'-Klasse fällt trotz der Refactorings immernoch in diese Kategorie. 



    \subsubsection{Open/Closed principle}
    Für gute Software ist es wichtig, dass sie offen für Erweiterung aber geschlossen für Veränderung ist. Code so zu gestalten, dass er überhaupt nicht verändert werden muss ist oft nicht möglich, es sollte aber so minimal wie möglich gehalten sein. Ein Beispiel im Code sind dabei die einzelnen Commands.
    Diese sind alle in einzelnen Klassen definiert, welche von einer abstrakten Oberklasse "Command" erben. Soll ein neuer Command hinzugefügt werden, so kann eine neue Unterklasse davon erstellt werden. Um diese im Projekt zu integrieren, muss dieser lediglich der 'CommandList' in der 'Decoder'- Klasse hinzugefügt werden.
    Diese minimale Modifikation des Codes wird durch den Einsatz eines Entwurfsmusters in \autoref{sec:entwurfsmuster} ermöglicht. 

    \subsubsection{Liskov substitution principle}

    \subsubsection{Interface segregation principle}

    \subsubsection{Dependency inversion principle}

    \subsection{GRASP}

    \subsubsection{High Cohesion}

    \subsubsection{Low Coupling}
    
    \subsection{DRY -- Don't Repeat Yourself}

    \section{Entwurfsmuster: Zuständigkeitskette}\label{sec:entwurfsmuster}

    Wie bereits in den Code Smells in \autoref{sec:refactoring} erwähnt, handelte es sich bei dem Teil des Codes, welcher die Operationcodes des eingelesenen Programmes decodiert um ein überdimensionalen Switch- Statement.
    Dieser sollte vermieden werden. Außerdem sollte die 'Cpu'- Klasse aufgelöst werden und jeder Command als eigene Klasse dargestellt werden. Zur Lösung dieser Probleme wurde die Zuständigkeitskette entdeckt.
    Dabei handelt es sich um ein Entwurfsmuster aus der Reihe der Verhaltensmuster, zu welchen auch der Beobachter gehört. 
    \\
    Eine Zuständigkeitskette dient dazu, verschiedene Anfragen eines Clients zu bearbeiten, welche an das selbe Interface gesendet werden. Dieses Interface wird dabei als Base Handler bezeichnet. Dazu wird die Anfrage an eine Kette von sogenannten konkreten Handlern geleitet.
    Ist eine Handler für die jeweilige Anfrage zuständig, so wird sie von diesem bearbeitet. Wenn nicht, wird sie an den nächsten Handler der Kette weitergegeben. Der Client muss dabei nicht wissen, von welchem Handler die Anfrage bearbeitet wurde und die konkreten Handler kennen lediglich ihren jeweilige Nachfolger.
    \\
    In diesem Fall ist die Anfrage der Operationcode des aktuellen Befehls im eingelesenen Programm, welcher von der 'Simulator'- Klasse in der Rolle als Client gestellt wird. Die konkreten Handler sind die einzelnen Commands, welche in der Methode 'isOpCode()' überprüfen, ob sie für den Befehl zuständig sind.
    Im gegensatz zur Originalimplementierung ist hier allerdings die 'Decoder'- Klasse zwischen Client und konreten Handlern, in welcher alle Handler in einer Liste aufgeführt sind, durch welche dann iteriert wird. Anstatt dass jeder konkrete Handler seinen Nachfolger und nur diesen kennt, wird die Kette vollständig in der 'Decoder'- Klasse definiert.
    Diese Praxis weicht zwar von dem origalen Entwurfsmuster ab, verringert aber die Anzahl der Methoden in der 'Command'-Klasse und gestaltet den Aufbau und damit auch die Erweiterung der Kette übersichtlicher, da neue Commands lediglich der 'CommandList' hinzugefügt werden müssen,
    anstatt sie einzeln zu instanziieren und sie als nächsten Handler des zuvor letzten zu definieren.

\end{document}
